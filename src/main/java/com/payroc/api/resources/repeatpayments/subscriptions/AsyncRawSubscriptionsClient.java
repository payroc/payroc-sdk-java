/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.payroc.api.resources.repeatpayments.subscriptions;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.payroc.api.core.ClientOptions;
import com.payroc.api.core.MediaTypes;
import com.payroc.api.core.ObjectMappers;
import com.payroc.api.core.PayrocApiApiException;
import com.payroc.api.core.PayrocApiException;
import com.payroc.api.core.PayrocApiHttpResponse;
import com.payroc.api.core.QueryStringMapper;
import com.payroc.api.core.RequestOptions;
import com.payroc.api.core.pagination.AsyncPayrocPager;
import com.payroc.api.errors.BadRequestError;
import com.payroc.api.errors.ConflictError;
import com.payroc.api.errors.ForbiddenError;
import com.payroc.api.errors.InternalServerError;
import com.payroc.api.errors.NotAcceptableError;
import com.payroc.api.errors.NotFoundError;
import com.payroc.api.errors.UnauthorizedError;
import com.payroc.api.errors.UnsupportedMediaTypeError;
import com.payroc.api.resources.repeatpayments.subscriptions.requests.DeactivateSubscriptionsRequest;
import com.payroc.api.resources.repeatpayments.subscriptions.requests.ListSubscriptionsRequest;
import com.payroc.api.resources.repeatpayments.subscriptions.requests.PartiallyUpdateSubscriptionsRequest;
import com.payroc.api.resources.repeatpayments.subscriptions.requests.ReactivateSubscriptionsRequest;
import com.payroc.api.resources.repeatpayments.subscriptions.requests.RetrieveSubscriptionsRequest;
import com.payroc.api.resources.repeatpayments.subscriptions.requests.SubscriptionPaymentRequest;
import com.payroc.api.resources.repeatpayments.subscriptions.requests.SubscriptionRequest;
import com.payroc.api.types.FiveHundred;
import com.payroc.api.types.FourHundred;
import com.payroc.api.types.FourHundredFifteen;
import com.payroc.api.types.FourHundredFour;
import com.payroc.api.types.FourHundredNine;
import com.payroc.api.types.FourHundredOne;
import com.payroc.api.types.FourHundredSix;
import com.payroc.api.types.Subscription;
import com.payroc.api.types.SubscriptionPaginatedList;
import com.payroc.api.types.SubscriptionPayment;
import java.io.IOException;
import java.util.concurrent.CompletableFuture;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.Headers;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okhttp3.ResponseBody;
import org.jetbrains.annotations.NotNull;

public class AsyncRawSubscriptionsClient {
    protected final ClientOptions clientOptions;

    public AsyncRawSubscriptionsClient(ClientOptions clientOptions) {
        this.clientOptions = clientOptions;
    }

    /**
     * Use this method to return a <a href="https://docs.payroc.com/api/pagination">paginated</a> list of subscriptions.
     * <p>Note: If you want to view the details of a specific subscription and you have its subscriptionId, use our <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/retrieve">Retrieve subscription</a> method.</p>
     * <p>Use query parameters to filter the list of results that we return, for example, to search for subscriptions for a customer, a payment plan, or frequency.</p>
     * <p>Our gateway returns information about the following for each subscription in the list:</p>
     * <ul>
     * <li>Payment plan the subscription is linked to.</li>
     * <li>Secure token that represents cardholder’s payment details.</li>
     * <li>Current state of the subscription, including its status, next due date, and invoices.</li>
     * <li>Fees for setup and the cost of the recurring order.</li>
     * <li>Subscription length, end date, and frequency.</li>
     * </ul>
     * <p>For each subscription, we also return the subscriptionId, the paymentPlanId, and the secureTokenId, which you can use to perform follow-actions.</p>
     */
    public CompletableFuture<PayrocApiHttpResponse<CompletableFuture<AsyncPayrocPager<Subscription>>>> list(
            String processingTerminalId) {
        return list(processingTerminalId, ListSubscriptionsRequest.builder().build());
    }

    /**
     * Use this method to return a <a href="https://docs.payroc.com/api/pagination">paginated</a> list of subscriptions.
     * <p>Note: If you want to view the details of a specific subscription and you have its subscriptionId, use our <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/retrieve">Retrieve subscription</a> method.</p>
     * <p>Use query parameters to filter the list of results that we return, for example, to search for subscriptions for a customer, a payment plan, or frequency.</p>
     * <p>Our gateway returns information about the following for each subscription in the list:</p>
     * <ul>
     * <li>Payment plan the subscription is linked to.</li>
     * <li>Secure token that represents cardholder’s payment details.</li>
     * <li>Current state of the subscription, including its status, next due date, and invoices.</li>
     * <li>Fees for setup and the cost of the recurring order.</li>
     * <li>Subscription length, end date, and frequency.</li>
     * </ul>
     * <p>For each subscription, we also return the subscriptionId, the paymentPlanId, and the secureTokenId, which you can use to perform follow-actions.</p>
     */
    public CompletableFuture<PayrocApiHttpResponse<CompletableFuture<AsyncPayrocPager<Subscription>>>> list(
            String processingTerminalId, RequestOptions requestOptions) {
        return list(processingTerminalId, ListSubscriptionsRequest.builder().build(), requestOptions);
    }

    /**
     * Use this method to return a <a href="https://docs.payroc.com/api/pagination">paginated</a> list of subscriptions.
     * <p>Note: If you want to view the details of a specific subscription and you have its subscriptionId, use our <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/retrieve">Retrieve subscription</a> method.</p>
     * <p>Use query parameters to filter the list of results that we return, for example, to search for subscriptions for a customer, a payment plan, or frequency.</p>
     * <p>Our gateway returns information about the following for each subscription in the list:</p>
     * <ul>
     * <li>Payment plan the subscription is linked to.</li>
     * <li>Secure token that represents cardholder’s payment details.</li>
     * <li>Current state of the subscription, including its status, next due date, and invoices.</li>
     * <li>Fees for setup and the cost of the recurring order.</li>
     * <li>Subscription length, end date, and frequency.</li>
     * </ul>
     * <p>For each subscription, we also return the subscriptionId, the paymentPlanId, and the secureTokenId, which you can use to perform follow-actions.</p>
     */
    public CompletableFuture<PayrocApiHttpResponse<CompletableFuture<AsyncPayrocPager<Subscription>>>> list(
            String processingTerminalId, ListSubscriptionsRequest request) {
        return list(processingTerminalId, request, null);
    }

    /**
     * Use this method to return a <a href="https://docs.payroc.com/api/pagination">paginated</a> list of subscriptions.
     * <p>Note: If you want to view the details of a specific subscription and you have its subscriptionId, use our <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/retrieve">Retrieve subscription</a> method.</p>
     * <p>Use query parameters to filter the list of results that we return, for example, to search for subscriptions for a customer, a payment plan, or frequency.</p>
     * <p>Our gateway returns information about the following for each subscription in the list:</p>
     * <ul>
     * <li>Payment plan the subscription is linked to.</li>
     * <li>Secure token that represents cardholder’s payment details.</li>
     * <li>Current state of the subscription, including its status, next due date, and invoices.</li>
     * <li>Fees for setup and the cost of the recurring order.</li>
     * <li>Subscription length, end date, and frequency.</li>
     * </ul>
     * <p>For each subscription, we also return the subscriptionId, the paymentPlanId, and the secureTokenId, which you can use to perform follow-actions.</p>
     */
    public CompletableFuture<PayrocApiHttpResponse<CompletableFuture<AsyncPayrocPager<Subscription>>>> list(
            String processingTerminalId, ListSubscriptionsRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getApiURL())
                .newBuilder()
                .addPathSegments("processing-terminals")
                .addPathSegment(processingTerminalId)
                .addPathSegments("subscriptions");
        if (request.getCustomerName().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "customerName", request.getCustomerName().get(), false);
        }
        if (request.getLast4().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "last4", request.getLast4().get(), false);
        }
        if (request.getPaymentPlan().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "paymentPlan", request.getPaymentPlan().get(), false);
        }
        if (request.getFrequency().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "frequency", request.getFrequency().get(), false);
        }
        if (request.getStatus().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "status", request.getStatus().get(), false);
        }
        if (request.getEndDate().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "endDate", request.getEndDate().get(), false);
        }
        if (request.getNextDueDate().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "nextDueDate", request.getNextDueDate().get(), false);
        }
        if (request.getBefore().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "before", request.getBefore().get(), false);
        }
        if (request.getAfter().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "after", request.getAfter().get(), false);
        }
        if (request.getLimit().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "limit", request.getLimit().get(), false);
        }
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PayrocApiHttpResponse<CompletableFuture<AsyncPayrocPager<Subscription>>>> future =
                new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        SubscriptionPaginatedList parsedResponse = ObjectMappers.JSON_MAPPER.readValue(
                                responseBodyString, SubscriptionPaginatedList.class);
                        future.complete(new PayrocApiHttpResponse<>(
                                AsyncPayrocPager.createAsync(parsedResponse, clientOptions, requestOptions), response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundred.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundredOne.class),
                                        response));
                                return;
                            case 403:
                                future.completeExceptionally(new ForbiddenError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 406:
                                future.completeExceptionally(new NotAcceptableError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundredSix.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FiveHundred.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new PayrocApiApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PayrocApiException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PayrocApiException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Use this method to assign a customer to a payment plan.
     * <p><strong>Note:</strong> This method is part of our Repeat Payments feature. To help you understand how this method works with our Payment plans endpoints, go to <a href="https://docs.payroc.com/guides/take-payments/repeat-payments">Repeat Payments</a>.</p>
     * <p>When you create a subscription you need to provide a unique subscriptionId that you use to run follow-on actions:</p>
     * <ul>
     * <li><a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/retrieve">Retrieve Subscription</a> - View the details of the subscription.</li>
     * <li><a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/partially-update">Update Subscription</a> - Update the details of the subscription.</li>
     * <li><a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/deactivate">Deactivate Subscription</a> - Stop taking payments for the subscription.</li>
     * <li><a href="https://docs.payroc.com/api/schema/payments/subscriptions/reactivate">Re-activate Subscription</a> - Start taking payments again for the subscription.</li>
     * <li><a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/pay">Pay Manual Subscription</a> - Manually collect a payment for the subscription.</li>
     * </ul>
     * <p>The request includes the following settings:</p>
     * <ul>
     * <li><strong>paymentPlanId</strong> - Unique identifier of the payment plan that the merchant wants to use. If you don't have the paymentPlanId, use our <a href="https://docs.payroc.com/api/schema/repeat-payments/payment-plans/list">List Payment Plans</a> method to search for the payment plan.</li>
     * <li><strong>paymentMethod</strong> - Object that contains information about the secure token, which represents the customer's card details or bank account details.</li>
     * <li><strong>startDate</strong> - Date that you want to start to take payments.</li>
     * </ul>
     * <p>You can also update the settings that the subscription inherited from the payment plan, for example, you can change the amount for each payment. If you change the settings for the subscription, it doesn't change the settings in the payment plan that it's linked to.</p>
     */
    public CompletableFuture<PayrocApiHttpResponse<Subscription>> create(
            String processingTerminalId, SubscriptionRequest request) {
        return create(processingTerminalId, request, null);
    }

    /**
     * Use this method to assign a customer to a payment plan.
     * <p><strong>Note:</strong> This method is part of our Repeat Payments feature. To help you understand how this method works with our Payment plans endpoints, go to <a href="https://docs.payroc.com/guides/take-payments/repeat-payments">Repeat Payments</a>.</p>
     * <p>When you create a subscription you need to provide a unique subscriptionId that you use to run follow-on actions:</p>
     * <ul>
     * <li><a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/retrieve">Retrieve Subscription</a> - View the details of the subscription.</li>
     * <li><a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/partially-update">Update Subscription</a> - Update the details of the subscription.</li>
     * <li><a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/deactivate">Deactivate Subscription</a> - Stop taking payments for the subscription.</li>
     * <li><a href="https://docs.payroc.com/api/schema/payments/subscriptions/reactivate">Re-activate Subscription</a> - Start taking payments again for the subscription.</li>
     * <li><a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/pay">Pay Manual Subscription</a> - Manually collect a payment for the subscription.</li>
     * </ul>
     * <p>The request includes the following settings:</p>
     * <ul>
     * <li><strong>paymentPlanId</strong> - Unique identifier of the payment plan that the merchant wants to use. If you don't have the paymentPlanId, use our <a href="https://docs.payroc.com/api/schema/repeat-payments/payment-plans/list">List Payment Plans</a> method to search for the payment plan.</li>
     * <li><strong>paymentMethod</strong> - Object that contains information about the secure token, which represents the customer's card details or bank account details.</li>
     * <li><strong>startDate</strong> - Date that you want to start to take payments.</li>
     * </ul>
     * <p>You can also update the settings that the subscription inherited from the payment plan, for example, you can change the amount for each payment. If you change the settings for the subscription, it doesn't change the settings in the payment plan that it's linked to.</p>
     */
    public CompletableFuture<PayrocApiHttpResponse<Subscription>> create(
            String processingTerminalId, SubscriptionRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getApiURL())
                .newBuilder()
                .addPathSegments("processing-terminals")
                .addPathSegment(processingTerminalId)
                .addPathSegments("subscriptions");
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json");
        _requestBuilder.addHeader("Idempotency-Key", request.getIdempotencyKey());
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PayrocApiHttpResponse<Subscription>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new PayrocApiHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Subscription.class), response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundred.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundredOne.class),
                                        response));
                                return;
                            case 403:
                                future.completeExceptionally(new ForbiddenError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 406:
                                future.completeExceptionally(new NotAcceptableError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundredSix.class),
                                        response));
                                return;
                            case 409:
                                future.completeExceptionally(new ConflictError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundredNine.class),
                                        response));
                                return;
                            case 415:
                                future.completeExceptionally(new UnsupportedMediaTypeError(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, FourHundredFifteen.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FiveHundred.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new PayrocApiApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PayrocApiException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PayrocApiException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Use this method to retrieve information about a subscription.
     * <p>To retrieve a subscription, you need its subscriptionId. You sent the subscriptionId in the request of the <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create">Create subscription</a> method.</p>
     * <p><strong>Note:</strong> If you don't have the subscriptionId, use our <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/list">List subscriptions</a> method to search for the subscription.</p>
     * <p>Our gateway returns information about the following for the subscription:</p>
     * <ul>
     * <li>Payment plan the subscription is linked to.</li>
     * <li>Secure token that represents cardholder’s payment details.</li>
     * <li>Current state of the subscription, including its status, next due date, and invoices.</li>
     * <li>Fees for setup and the cost of the recurring order.</li>
     * <li>Subscription length, end date, and frequency.</li>
     * </ul>
     * <p>We also return the paymentPlanId and the secureTokenId, which you can use to perform follow-on actions.</p>
     */
    public CompletableFuture<PayrocApiHttpResponse<Subscription>> retrieve(
            String processingTerminalId, String subscriptionId) {
        return retrieve(
                processingTerminalId,
                subscriptionId,
                RetrieveSubscriptionsRequest.builder().build());
    }

    /**
     * Use this method to retrieve information about a subscription.
     * <p>To retrieve a subscription, you need its subscriptionId. You sent the subscriptionId in the request of the <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create">Create subscription</a> method.</p>
     * <p><strong>Note:</strong> If you don't have the subscriptionId, use our <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/list">List subscriptions</a> method to search for the subscription.</p>
     * <p>Our gateway returns information about the following for the subscription:</p>
     * <ul>
     * <li>Payment plan the subscription is linked to.</li>
     * <li>Secure token that represents cardholder’s payment details.</li>
     * <li>Current state of the subscription, including its status, next due date, and invoices.</li>
     * <li>Fees for setup and the cost of the recurring order.</li>
     * <li>Subscription length, end date, and frequency.</li>
     * </ul>
     * <p>We also return the paymentPlanId and the secureTokenId, which you can use to perform follow-on actions.</p>
     */
    public CompletableFuture<PayrocApiHttpResponse<Subscription>> retrieve(
            String processingTerminalId, String subscriptionId, RequestOptions requestOptions) {
        return retrieve(
                processingTerminalId,
                subscriptionId,
                RetrieveSubscriptionsRequest.builder().build(),
                requestOptions);
    }

    /**
     * Use this method to retrieve information about a subscription.
     * <p>To retrieve a subscription, you need its subscriptionId. You sent the subscriptionId in the request of the <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create">Create subscription</a> method.</p>
     * <p><strong>Note:</strong> If you don't have the subscriptionId, use our <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/list">List subscriptions</a> method to search for the subscription.</p>
     * <p>Our gateway returns information about the following for the subscription:</p>
     * <ul>
     * <li>Payment plan the subscription is linked to.</li>
     * <li>Secure token that represents cardholder’s payment details.</li>
     * <li>Current state of the subscription, including its status, next due date, and invoices.</li>
     * <li>Fees for setup and the cost of the recurring order.</li>
     * <li>Subscription length, end date, and frequency.</li>
     * </ul>
     * <p>We also return the paymentPlanId and the secureTokenId, which you can use to perform follow-on actions.</p>
     */
    public CompletableFuture<PayrocApiHttpResponse<Subscription>> retrieve(
            String processingTerminalId, String subscriptionId, RetrieveSubscriptionsRequest request) {
        return retrieve(processingTerminalId, subscriptionId, request, null);
    }

    /**
     * Use this method to retrieve information about a subscription.
     * <p>To retrieve a subscription, you need its subscriptionId. You sent the subscriptionId in the request of the <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create">Create subscription</a> method.</p>
     * <p><strong>Note:</strong> If you don't have the subscriptionId, use our <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/list">List subscriptions</a> method to search for the subscription.</p>
     * <p>Our gateway returns information about the following for the subscription:</p>
     * <ul>
     * <li>Payment plan the subscription is linked to.</li>
     * <li>Secure token that represents cardholder’s payment details.</li>
     * <li>Current state of the subscription, including its status, next due date, and invoices.</li>
     * <li>Fees for setup and the cost of the recurring order.</li>
     * <li>Subscription length, end date, and frequency.</li>
     * </ul>
     * <p>We also return the paymentPlanId and the secureTokenId, which you can use to perform follow-on actions.</p>
     */
    public CompletableFuture<PayrocApiHttpResponse<Subscription>> retrieve(
            String processingTerminalId,
            String subscriptionId,
            RetrieveSubscriptionsRequest request,
            RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getApiURL())
                .newBuilder()
                .addPathSegments("processing-terminals")
                .addPathSegment(processingTerminalId)
                .addPathSegments("subscriptions")
                .addPathSegment(subscriptionId);
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PayrocApiHttpResponse<Subscription>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new PayrocApiHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Subscription.class), response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundred.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundredOne.class),
                                        response));
                                return;
                            case 403:
                                future.completeExceptionally(new ForbiddenError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundredFour.class),
                                        response));
                                return;
                            case 406:
                                future.completeExceptionally(new NotAcceptableError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundredSix.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FiveHundred.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new PayrocApiApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PayrocApiException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PayrocApiException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Use this method to partially update a subscription. Structure your request to follow the <a href="https://datatracker.ietf.org/doc/html/rfc6902">RFC 6902</a> standard.
     * <p>To update a subscription, you need its subscriptionId, which you sent in the request of the <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create">Create subscription</a> method.</p>
     * <p><strong>Note:</strong> If you don't have the subscriptionId, use our <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/list">List subscriptions</a> method to search for the payment.</p>
     * <p>You can update all of the properties of the subscription except for the following:</p>
     * <p><strong>Can't delete</strong></p>
     * <ul>
     * <li>recurringOrder</li>
     * <li>description</li>
     * <li>name</li>
     * </ul>
     * <p><strong>Can't perform any PATCH operation</strong></p>
     * <ul>
     * <li>currentState</li>
     * <li>type</li>
     * <li>frequency</li>
     * <li>paymentPlan</li>
     * </ul>
     */
    public CompletableFuture<PayrocApiHttpResponse<Subscription>> partiallyUpdate(
            String processingTerminalId, String subscriptionId, PartiallyUpdateSubscriptionsRequest request) {
        return partiallyUpdate(processingTerminalId, subscriptionId, request, null);
    }

    /**
     * Use this method to partially update a subscription. Structure your request to follow the <a href="https://datatracker.ietf.org/doc/html/rfc6902">RFC 6902</a> standard.
     * <p>To update a subscription, you need its subscriptionId, which you sent in the request of the <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create">Create subscription</a> method.</p>
     * <p><strong>Note:</strong> If you don't have the subscriptionId, use our <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/list">List subscriptions</a> method to search for the payment.</p>
     * <p>You can update all of the properties of the subscription except for the following:</p>
     * <p><strong>Can't delete</strong></p>
     * <ul>
     * <li>recurringOrder</li>
     * <li>description</li>
     * <li>name</li>
     * </ul>
     * <p><strong>Can't perform any PATCH operation</strong></p>
     * <ul>
     * <li>currentState</li>
     * <li>type</li>
     * <li>frequency</li>
     * <li>paymentPlan</li>
     * </ul>
     */
    public CompletableFuture<PayrocApiHttpResponse<Subscription>> partiallyUpdate(
            String processingTerminalId,
            String subscriptionId,
            PartiallyUpdateSubscriptionsRequest request,
            RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getApiURL())
                .newBuilder()
                .addPathSegments("processing-terminals")
                .addPathSegment(processingTerminalId)
                .addPathSegments("subscriptions")
                .addPathSegment(subscriptionId);
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request.getBody()), MediaTypes.APPLICATION_JSON);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("PATCH", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json");
        _requestBuilder.addHeader("Idempotency-Key", request.getIdempotencyKey());
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PayrocApiHttpResponse<Subscription>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new PayrocApiHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Subscription.class), response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundred.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundredOne.class),
                                        response));
                                return;
                            case 403:
                                future.completeExceptionally(new ForbiddenError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundredFour.class),
                                        response));
                                return;
                            case 406:
                                future.completeExceptionally(new NotAcceptableError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundredSix.class),
                                        response));
                                return;
                            case 409:
                                future.completeExceptionally(new ConflictError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundredNine.class),
                                        response));
                                return;
                            case 415:
                                future.completeExceptionally(new UnsupportedMediaTypeError(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, FourHundredFifteen.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FiveHundred.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new PayrocApiApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PayrocApiException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PayrocApiException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Use this method to deactivate a subscription.
     * <p>To deactivate a subscription, you need its subscriptionId, which you sent in the request of the <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create">Create Subscription</a> method.</p>
     * <p><strong>Note:</strong> If you don't have the subscriptionId, use our <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/list">List Subscriptions</a> method to search for the subscription.</p>
     * <p>If your request is successful, our gateway stops taking payments from the customer.</p>
     * <p>To reactivate the subscription, use our <a href="https://docs.payroc.com/api/schema/payments/subscriptions/reactivate">Reactivate Subscription</a> method.</p>
     */
    public CompletableFuture<PayrocApiHttpResponse<Subscription>> deactivate(
            String processingTerminalId, String subscriptionId) {
        return deactivate(
                processingTerminalId,
                subscriptionId,
                DeactivateSubscriptionsRequest.builder().build());
    }

    /**
     * Use this method to deactivate a subscription.
     * <p>To deactivate a subscription, you need its subscriptionId, which you sent in the request of the <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create">Create Subscription</a> method.</p>
     * <p><strong>Note:</strong> If you don't have the subscriptionId, use our <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/list">List Subscriptions</a> method to search for the subscription.</p>
     * <p>If your request is successful, our gateway stops taking payments from the customer.</p>
     * <p>To reactivate the subscription, use our <a href="https://docs.payroc.com/api/schema/payments/subscriptions/reactivate">Reactivate Subscription</a> method.</p>
     */
    public CompletableFuture<PayrocApiHttpResponse<Subscription>> deactivate(
            String processingTerminalId, String subscriptionId, RequestOptions requestOptions) {
        return deactivate(
                processingTerminalId,
                subscriptionId,
                DeactivateSubscriptionsRequest.builder().build(),
                requestOptions);
    }

    /**
     * Use this method to deactivate a subscription.
     * <p>To deactivate a subscription, you need its subscriptionId, which you sent in the request of the <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create">Create Subscription</a> method.</p>
     * <p><strong>Note:</strong> If you don't have the subscriptionId, use our <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/list">List Subscriptions</a> method to search for the subscription.</p>
     * <p>If your request is successful, our gateway stops taking payments from the customer.</p>
     * <p>To reactivate the subscription, use our <a href="https://docs.payroc.com/api/schema/payments/subscriptions/reactivate">Reactivate Subscription</a> method.</p>
     */
    public CompletableFuture<PayrocApiHttpResponse<Subscription>> deactivate(
            String processingTerminalId, String subscriptionId, DeactivateSubscriptionsRequest request) {
        return deactivate(processingTerminalId, subscriptionId, request, null);
    }

    /**
     * Use this method to deactivate a subscription.
     * <p>To deactivate a subscription, you need its subscriptionId, which you sent in the request of the <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create">Create Subscription</a> method.</p>
     * <p><strong>Note:</strong> If you don't have the subscriptionId, use our <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/list">List Subscriptions</a> method to search for the subscription.</p>
     * <p>If your request is successful, our gateway stops taking payments from the customer.</p>
     * <p>To reactivate the subscription, use our <a href="https://docs.payroc.com/api/schema/payments/subscriptions/reactivate">Reactivate Subscription</a> method.</p>
     */
    public CompletableFuture<PayrocApiHttpResponse<Subscription>> deactivate(
            String processingTerminalId,
            String subscriptionId,
            DeactivateSubscriptionsRequest request,
            RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getApiURL())
                .newBuilder()
                .addPathSegments("processing-terminals")
                .addPathSegment(processingTerminalId)
                .addPathSegments("subscriptions")
                .addPathSegment(subscriptionId)
                .addPathSegments("deactivate");
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("POST", RequestBody.create("", null))
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PayrocApiHttpResponse<Subscription>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new PayrocApiHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Subscription.class), response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundred.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundredOne.class),
                                        response));
                                return;
                            case 403:
                                future.completeExceptionally(new ForbiddenError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundredFour.class),
                                        response));
                                return;
                            case 406:
                                future.completeExceptionally(new NotAcceptableError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundredSix.class),
                                        response));
                                return;
                            case 409:
                                future.completeExceptionally(new ConflictError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundredNine.class),
                                        response));
                                return;
                            case 415:
                                future.completeExceptionally(new UnsupportedMediaTypeError(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, FourHundredFifteen.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FiveHundred.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new PayrocApiApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PayrocApiException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PayrocApiException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Use this method to reactivate a subscription.
     * <p>To reactivate a subscription, you need its subscriptionId, which you sent in the request of the <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create">Create Subscription</a> method.</p>
     * <p><strong>Note:</strong> If you don't have the subscriptionId, use our <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/list">List Subscriptions</a> method to search for the subscription.</p>
     * <p>If your request is successful, our gateway restarts taking payments from the customer.</p>
     * <p>To deactivate the subscription, use our <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/deactivate">Deactivate Subscription</a> method.</p>
     */
    public CompletableFuture<PayrocApiHttpResponse<Subscription>> reactivate(
            String processingTerminalId, String subscriptionId) {
        return reactivate(
                processingTerminalId,
                subscriptionId,
                ReactivateSubscriptionsRequest.builder().build());
    }

    /**
     * Use this method to reactivate a subscription.
     * <p>To reactivate a subscription, you need its subscriptionId, which you sent in the request of the <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create">Create Subscription</a> method.</p>
     * <p><strong>Note:</strong> If you don't have the subscriptionId, use our <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/list">List Subscriptions</a> method to search for the subscription.</p>
     * <p>If your request is successful, our gateway restarts taking payments from the customer.</p>
     * <p>To deactivate the subscription, use our <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/deactivate">Deactivate Subscription</a> method.</p>
     */
    public CompletableFuture<PayrocApiHttpResponse<Subscription>> reactivate(
            String processingTerminalId, String subscriptionId, RequestOptions requestOptions) {
        return reactivate(
                processingTerminalId,
                subscriptionId,
                ReactivateSubscriptionsRequest.builder().build(),
                requestOptions);
    }

    /**
     * Use this method to reactivate a subscription.
     * <p>To reactivate a subscription, you need its subscriptionId, which you sent in the request of the <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create">Create Subscription</a> method.</p>
     * <p><strong>Note:</strong> If you don't have the subscriptionId, use our <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/list">List Subscriptions</a> method to search for the subscription.</p>
     * <p>If your request is successful, our gateway restarts taking payments from the customer.</p>
     * <p>To deactivate the subscription, use our <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/deactivate">Deactivate Subscription</a> method.</p>
     */
    public CompletableFuture<PayrocApiHttpResponse<Subscription>> reactivate(
            String processingTerminalId, String subscriptionId, ReactivateSubscriptionsRequest request) {
        return reactivate(processingTerminalId, subscriptionId, request, null);
    }

    /**
     * Use this method to reactivate a subscription.
     * <p>To reactivate a subscription, you need its subscriptionId, which you sent in the request of the <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create">Create Subscription</a> method.</p>
     * <p><strong>Note:</strong> If you don't have the subscriptionId, use our <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/list">List Subscriptions</a> method to search for the subscription.</p>
     * <p>If your request is successful, our gateway restarts taking payments from the customer.</p>
     * <p>To deactivate the subscription, use our <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/deactivate">Deactivate Subscription</a> method.</p>
     */
    public CompletableFuture<PayrocApiHttpResponse<Subscription>> reactivate(
            String processingTerminalId,
            String subscriptionId,
            ReactivateSubscriptionsRequest request,
            RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getApiURL())
                .newBuilder()
                .addPathSegments("processing-terminals")
                .addPathSegment(processingTerminalId)
                .addPathSegments("subscriptions")
                .addPathSegment(subscriptionId)
                .addPathSegments("reactivate");
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("POST", RequestBody.create("", null))
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PayrocApiHttpResponse<Subscription>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new PayrocApiHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Subscription.class), response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundred.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundredOne.class),
                                        response));
                                return;
                            case 403:
                                future.completeExceptionally(new ForbiddenError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundredFour.class),
                                        response));
                                return;
                            case 406:
                                future.completeExceptionally(new NotAcceptableError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundredSix.class),
                                        response));
                                return;
                            case 409:
                                future.completeExceptionally(new ConflictError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundredNine.class),
                                        response));
                                return;
                            case 415:
                                future.completeExceptionally(new UnsupportedMediaTypeError(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, FourHundredFifteen.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FiveHundred.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new PayrocApiApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PayrocApiException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PayrocApiException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Use this method to manually collect a payment linked to a subscription. You can manually collect a payment only if the merchant chose not to let our gateway automatically collect each payment.
     * <p>To manually collect a payment, you need the subscriptionId of the subscription that's linked to the payment. You sent the subscriptionId in the request of the <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create">Create Subscription</a> method.</p>
     * <p><strong>Note:</strong> If you don't have the subscriptionId, use our <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/list">List Subscriptions</a> method to search for the subscription.</p>
     * <p>The request includes an order object that contains information about the amount that you want to collect.</p>
     * <p>In the response, our gateway returns information about the payment and a paymentId. You can use the paymentId in follow-on actions with the <a href="https://docs.payroc.com/api/schema/card-payments/payments">Payments</a> endpoints or <a href="https://docs.payroc.com/api/schema/bank-transfer-payments/payments">Bank Transfer Payments</a> endpoints.</p>
     */
    public CompletableFuture<PayrocApiHttpResponse<SubscriptionPayment>> pay(
            String processingTerminalId, String subscriptionId, SubscriptionPaymentRequest request) {
        return pay(processingTerminalId, subscriptionId, request, null);
    }

    /**
     * Use this method to manually collect a payment linked to a subscription. You can manually collect a payment only if the merchant chose not to let our gateway automatically collect each payment.
     * <p>To manually collect a payment, you need the subscriptionId of the subscription that's linked to the payment. You sent the subscriptionId in the request of the <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/create">Create Subscription</a> method.</p>
     * <p><strong>Note:</strong> If you don't have the subscriptionId, use our <a href="https://docs.payroc.com/api/schema/repeat-payments/subscriptions/list">List Subscriptions</a> method to search for the subscription.</p>
     * <p>The request includes an order object that contains information about the amount that you want to collect.</p>
     * <p>In the response, our gateway returns information about the payment and a paymentId. You can use the paymentId in follow-on actions with the <a href="https://docs.payroc.com/api/schema/card-payments/payments">Payments</a> endpoints or <a href="https://docs.payroc.com/api/schema/bank-transfer-payments/payments">Bank Transfer Payments</a> endpoints.</p>
     */
    public CompletableFuture<PayrocApiHttpResponse<SubscriptionPayment>> pay(
            String processingTerminalId,
            String subscriptionId,
            SubscriptionPaymentRequest request,
            RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getApiURL())
                .newBuilder()
                .addPathSegments("processing-terminals")
                .addPathSegment(processingTerminalId)
                .addPathSegments("subscriptions")
                .addPathSegment(subscriptionId)
                .addPathSegments("pay");
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json");
        _requestBuilder.addHeader("Idempotency-Key", request.getIdempotencyKey());
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PayrocApiHttpResponse<SubscriptionPayment>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new PayrocApiHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, SubscriptionPayment.class),
                                response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundred.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundredOne.class),
                                        response));
                                return;
                            case 403:
                                future.completeExceptionally(new ForbiddenError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundredFour.class),
                                        response));
                                return;
                            case 406:
                                future.completeExceptionally(new NotAcceptableError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundredSix.class),
                                        response));
                                return;
                            case 409:
                                future.completeExceptionally(new ConflictError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FourHundredNine.class),
                                        response));
                                return;
                            case 415:
                                future.completeExceptionally(new UnsupportedMediaTypeError(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, FourHundredFifteen.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, FiveHundred.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new PayrocApiApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PayrocApiException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PayrocApiException("Network error executing HTTP request", e));
            }
        });
        return future;
    }
}
