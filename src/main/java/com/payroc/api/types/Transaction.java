/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.payroc.api.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.payroc.api.core.ObjectMappers;
import java.time.LocalDate;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = Transaction.Builder.class)
public final class Transaction {
    private final Optional<Integer> transactionId;

    private final Optional<TransactionType> type;

    private final Optional<LocalDate> date;

    private final Optional<Integer> amount;

    private final Optional<TransactionEntryMethod> entryMethod;

    private final Optional<LocalDate> createdDate;

    private final Optional<LocalDate> lastModifiedDate;

    private final Optional<TransactionStatus> status;

    private final Optional<Integer> cashbackAmount;

    private final Optional<TransactionInterchange> interchange;

    private final Optional<String> currency;

    private final Optional<MerchantSummary> merchant;

    private final Optional<SettledSummary> settled;

    private final Optional<BatchSummary> batch;

    private final Optional<CardSummary> card;

    private final Optional<AuthorizationSummary> authorization;

    private final Map<String, Object> additionalProperties;

    private Transaction(
            Optional<Integer> transactionId,
            Optional<TransactionType> type,
            Optional<LocalDate> date,
            Optional<Integer> amount,
            Optional<TransactionEntryMethod> entryMethod,
            Optional<LocalDate> createdDate,
            Optional<LocalDate> lastModifiedDate,
            Optional<TransactionStatus> status,
            Optional<Integer> cashbackAmount,
            Optional<TransactionInterchange> interchange,
            Optional<String> currency,
            Optional<MerchantSummary> merchant,
            Optional<SettledSummary> settled,
            Optional<BatchSummary> batch,
            Optional<CardSummary> card,
            Optional<AuthorizationSummary> authorization,
            Map<String, Object> additionalProperties) {
        this.transactionId = transactionId;
        this.type = type;
        this.date = date;
        this.amount = amount;
        this.entryMethod = entryMethod;
        this.createdDate = createdDate;
        this.lastModifiedDate = lastModifiedDate;
        this.status = status;
        this.cashbackAmount = cashbackAmount;
        this.interchange = interchange;
        this.currency = currency;
        this.merchant = merchant;
        this.settled = settled;
        this.batch = batch;
        this.card = card;
        this.authorization = authorization;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return Unique identifier that we assigned to the transaction.
     */
    @JsonProperty("transactionId")
    public Optional<Integer> getTransactionId() {
        return transactionId;
    }

    /**
     * @return Indicates the type of transaction. The value is one of the following:
     * <ul>
     * <li><code>capture</code> - Transaction is a sale.</li>
     * <li><code>return</code> - Transaction is a refund.</li>
     * </ul>
     */
    @JsonProperty("type")
    public Optional<TransactionType> getType() {
        return type;
    }

    /**
     * @return Date of the transaction. The format of this value is <strong>YYYY-MM-DD</strong>.
     */
    @JsonProperty("date")
    public Optional<LocalDate> getDate() {
        return date;
    }

    /**
     * @return Transaction amount. We return the value in the currency's lowest denomination, for example, cents.
     */
    @JsonProperty("amount")
    public Optional<Integer> getAmount() {
        return amount;
    }

    /**
     * @return Indicates how the merchant received the payment details.
     */
    @JsonProperty("entryMethod")
    public Optional<TransactionEntryMethod> getEntryMethod() {
        return entryMethod;
    }

    /**
     * @return Date that we received the transaction.  The format of this value is <strong>YYYY-MM-DD</strong>.
     */
    @JsonProperty("createdDate")
    public Optional<LocalDate> getCreatedDate() {
        return createdDate;
    }

    /**
     * @return Date that the transaction was last changed.  The format of this value is <strong>YYYY-MM-DD</strong>.
     */
    @JsonProperty("lastModifiedDate")
    public Optional<LocalDate> getLastModifiedDate() {
        return lastModifiedDate;
    }

    /**
     * @return Indicates the status of the transaction. The value is one of the following:
     * <ul>
     * <li><code>fullSuspense</code> – Merchant ran the transaction while their account was in full suspense.</li>
     * <li><code>heldAudited</code> – We have moved a transaction from fullSuspense and placed it on hold.</li>
     * <li><code>heldReleasedAudited</code> – We audited and released the transaction that we had previously held.</li>
     * <li><code>holdForSettlement30Days</code> - We are holding the transaction for a maximum of 30 days.</li>
     * <li><code>holdForSettlementDuplicate</code> - We held the transaction because the transaction may be a duplicate.</li>
     * <li><code>holdLongTerm</code> - We are holding the transaction for an extended period.</li>
     * <li><code>paid</code> – We have paid the transaction funds to the merchant.</li>
     * <li><code>paidByThirdParty</code> - A third party has paid the transaction funds to the merchant.</li>
     * <li><code>partialRelease</code> – We partially released the transaction funds.</li>
     * <li><code>pull</code> - We pulled the transaction, and the merchant does not receive funds for the transaction.</li>
     * <li><code>release</code> - We released the transaction that we previously held.</li>
     * <li><code>new</code> – We have prepared the funds from the transaction to send to the merchant.</li>
     * <li><code>held</code> – We held the transaction.</li>
     * <li><code>unknown</code> – No transaction status available.</li>
     * </ul>
     */
    @JsonProperty("status")
    public Optional<TransactionStatus> getStatus() {
        return status;
    }

    /**
     * @return Cashback amount. We return the value in the currency's lowest denomination, for example, cents.
     */
    @JsonProperty("cashbackAmount")
    public Optional<Integer> getCashbackAmount() {
        return cashbackAmount;
    }

    /**
     * @return Object that contains information about the interchange fees for the transaction.
     */
    @JsonProperty("interchange")
    public Optional<TransactionInterchange> getInterchange() {
        return interchange;
    }

    /**
     * @return Currency of the transaction. The value for the currency follows the <a href="https://www.iso.org/iso-4217-currency-codes.html">ISO 4217</a> standard.
     */
    @JsonProperty("currency")
    public Optional<String> getCurrency() {
        return currency;
    }

    @JsonProperty("merchant")
    public Optional<MerchantSummary> getMerchant() {
        return merchant;
    }

    @JsonProperty("settled")
    public Optional<SettledSummary> getSettled() {
        return settled;
    }

    @JsonProperty("batch")
    public Optional<BatchSummary> getBatch() {
        return batch;
    }

    @JsonProperty("card")
    public Optional<CardSummary> getCard() {
        return card;
    }

    @JsonProperty("authorization")
    public Optional<AuthorizationSummary> getAuthorization() {
        return authorization;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof Transaction && equalTo((Transaction) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(Transaction other) {
        return transactionId.equals(other.transactionId)
                && type.equals(other.type)
                && date.equals(other.date)
                && amount.equals(other.amount)
                && entryMethod.equals(other.entryMethod)
                && createdDate.equals(other.createdDate)
                && lastModifiedDate.equals(other.lastModifiedDate)
                && status.equals(other.status)
                && cashbackAmount.equals(other.cashbackAmount)
                && interchange.equals(other.interchange)
                && currency.equals(other.currency)
                && merchant.equals(other.merchant)
                && settled.equals(other.settled)
                && batch.equals(other.batch)
                && card.equals(other.card)
                && authorization.equals(other.authorization);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.transactionId,
                this.type,
                this.date,
                this.amount,
                this.entryMethod,
                this.createdDate,
                this.lastModifiedDate,
                this.status,
                this.cashbackAmount,
                this.interchange,
                this.currency,
                this.merchant,
                this.settled,
                this.batch,
                this.card,
                this.authorization);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<Integer> transactionId = Optional.empty();

        private Optional<TransactionType> type = Optional.empty();

        private Optional<LocalDate> date = Optional.empty();

        private Optional<Integer> amount = Optional.empty();

        private Optional<TransactionEntryMethod> entryMethod = Optional.empty();

        private Optional<LocalDate> createdDate = Optional.empty();

        private Optional<LocalDate> lastModifiedDate = Optional.empty();

        private Optional<TransactionStatus> status = Optional.empty();

        private Optional<Integer> cashbackAmount = Optional.empty();

        private Optional<TransactionInterchange> interchange = Optional.empty();

        private Optional<String> currency = Optional.empty();

        private Optional<MerchantSummary> merchant = Optional.empty();

        private Optional<SettledSummary> settled = Optional.empty();

        private Optional<BatchSummary> batch = Optional.empty();

        private Optional<CardSummary> card = Optional.empty();

        private Optional<AuthorizationSummary> authorization = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(Transaction other) {
            transactionId(other.getTransactionId());
            type(other.getType());
            date(other.getDate());
            amount(other.getAmount());
            entryMethod(other.getEntryMethod());
            createdDate(other.getCreatedDate());
            lastModifiedDate(other.getLastModifiedDate());
            status(other.getStatus());
            cashbackAmount(other.getCashbackAmount());
            interchange(other.getInterchange());
            currency(other.getCurrency());
            merchant(other.getMerchant());
            settled(other.getSettled());
            batch(other.getBatch());
            card(other.getCard());
            authorization(other.getAuthorization());
            return this;
        }

        /**
         * <p>Unique identifier that we assigned to the transaction.</p>
         */
        @JsonSetter(value = "transactionId", nulls = Nulls.SKIP)
        public Builder transactionId(Optional<Integer> transactionId) {
            this.transactionId = transactionId;
            return this;
        }

        public Builder transactionId(Integer transactionId) {
            this.transactionId = Optional.ofNullable(transactionId);
            return this;
        }

        /**
         * <p>Indicates the type of transaction. The value is one of the following:</p>
         * <ul>
         * <li><code>capture</code> - Transaction is a sale.</li>
         * <li><code>return</code> - Transaction is a refund.</li>
         * </ul>
         */
        @JsonSetter(value = "type", nulls = Nulls.SKIP)
        public Builder type(Optional<TransactionType> type) {
            this.type = type;
            return this;
        }

        public Builder type(TransactionType type) {
            this.type = Optional.ofNullable(type);
            return this;
        }

        /**
         * <p>Date of the transaction. The format of this value is <strong>YYYY-MM-DD</strong>.</p>
         */
        @JsonSetter(value = "date", nulls = Nulls.SKIP)
        public Builder date(Optional<LocalDate> date) {
            this.date = date;
            return this;
        }

        public Builder date(LocalDate date) {
            this.date = Optional.ofNullable(date);
            return this;
        }

        /**
         * <p>Transaction amount. We return the value in the currency's lowest denomination, for example, cents.</p>
         */
        @JsonSetter(value = "amount", nulls = Nulls.SKIP)
        public Builder amount(Optional<Integer> amount) {
            this.amount = amount;
            return this;
        }

        public Builder amount(Integer amount) {
            this.amount = Optional.ofNullable(amount);
            return this;
        }

        /**
         * <p>Indicates how the merchant received the payment details.</p>
         */
        @JsonSetter(value = "entryMethod", nulls = Nulls.SKIP)
        public Builder entryMethod(Optional<TransactionEntryMethod> entryMethod) {
            this.entryMethod = entryMethod;
            return this;
        }

        public Builder entryMethod(TransactionEntryMethod entryMethod) {
            this.entryMethod = Optional.ofNullable(entryMethod);
            return this;
        }

        /**
         * <p>Date that we received the transaction.  The format of this value is <strong>YYYY-MM-DD</strong>.</p>
         */
        @JsonSetter(value = "createdDate", nulls = Nulls.SKIP)
        public Builder createdDate(Optional<LocalDate> createdDate) {
            this.createdDate = createdDate;
            return this;
        }

        public Builder createdDate(LocalDate createdDate) {
            this.createdDate = Optional.ofNullable(createdDate);
            return this;
        }

        /**
         * <p>Date that the transaction was last changed.  The format of this value is <strong>YYYY-MM-DD</strong>.</p>
         */
        @JsonSetter(value = "lastModifiedDate", nulls = Nulls.SKIP)
        public Builder lastModifiedDate(Optional<LocalDate> lastModifiedDate) {
            this.lastModifiedDate = lastModifiedDate;
            return this;
        }

        public Builder lastModifiedDate(LocalDate lastModifiedDate) {
            this.lastModifiedDate = Optional.ofNullable(lastModifiedDate);
            return this;
        }

        /**
         * <p>Indicates the status of the transaction. The value is one of the following:</p>
         * <ul>
         * <li><code>fullSuspense</code> – Merchant ran the transaction while their account was in full suspense.</li>
         * <li><code>heldAudited</code> – We have moved a transaction from fullSuspense and placed it on hold.</li>
         * <li><code>heldReleasedAudited</code> – We audited and released the transaction that we had previously held.</li>
         * <li><code>holdForSettlement30Days</code> - We are holding the transaction for a maximum of 30 days.</li>
         * <li><code>holdForSettlementDuplicate</code> - We held the transaction because the transaction may be a duplicate.</li>
         * <li><code>holdLongTerm</code> - We are holding the transaction for an extended period.</li>
         * <li><code>paid</code> – We have paid the transaction funds to the merchant.</li>
         * <li><code>paidByThirdParty</code> - A third party has paid the transaction funds to the merchant.</li>
         * <li><code>partialRelease</code> – We partially released the transaction funds.</li>
         * <li><code>pull</code> - We pulled the transaction, and the merchant does not receive funds for the transaction.</li>
         * <li><code>release</code> - We released the transaction that we previously held.</li>
         * <li><code>new</code> – We have prepared the funds from the transaction to send to the merchant.</li>
         * <li><code>held</code> – We held the transaction.</li>
         * <li><code>unknown</code> – No transaction status available.</li>
         * </ul>
         */
        @JsonSetter(value = "status", nulls = Nulls.SKIP)
        public Builder status(Optional<TransactionStatus> status) {
            this.status = status;
            return this;
        }

        public Builder status(TransactionStatus status) {
            this.status = Optional.ofNullable(status);
            return this;
        }

        /**
         * <p>Cashback amount. We return the value in the currency's lowest denomination, for example, cents.</p>
         */
        @JsonSetter(value = "cashbackAmount", nulls = Nulls.SKIP)
        public Builder cashbackAmount(Optional<Integer> cashbackAmount) {
            this.cashbackAmount = cashbackAmount;
            return this;
        }

        public Builder cashbackAmount(Integer cashbackAmount) {
            this.cashbackAmount = Optional.ofNullable(cashbackAmount);
            return this;
        }

        /**
         * <p>Object that contains information about the interchange fees for the transaction.</p>
         */
        @JsonSetter(value = "interchange", nulls = Nulls.SKIP)
        public Builder interchange(Optional<TransactionInterchange> interchange) {
            this.interchange = interchange;
            return this;
        }

        public Builder interchange(TransactionInterchange interchange) {
            this.interchange = Optional.ofNullable(interchange);
            return this;
        }

        /**
         * <p>Currency of the transaction. The value for the currency follows the <a href="https://www.iso.org/iso-4217-currency-codes.html">ISO 4217</a> standard.</p>
         */
        @JsonSetter(value = "currency", nulls = Nulls.SKIP)
        public Builder currency(Optional<String> currency) {
            this.currency = currency;
            return this;
        }

        public Builder currency(String currency) {
            this.currency = Optional.ofNullable(currency);
            return this;
        }

        @JsonSetter(value = "merchant", nulls = Nulls.SKIP)
        public Builder merchant(Optional<MerchantSummary> merchant) {
            this.merchant = merchant;
            return this;
        }

        public Builder merchant(MerchantSummary merchant) {
            this.merchant = Optional.ofNullable(merchant);
            return this;
        }

        @JsonSetter(value = "settled", nulls = Nulls.SKIP)
        public Builder settled(Optional<SettledSummary> settled) {
            this.settled = settled;
            return this;
        }

        public Builder settled(SettledSummary settled) {
            this.settled = Optional.ofNullable(settled);
            return this;
        }

        @JsonSetter(value = "batch", nulls = Nulls.SKIP)
        public Builder batch(Optional<BatchSummary> batch) {
            this.batch = batch;
            return this;
        }

        public Builder batch(BatchSummary batch) {
            this.batch = Optional.ofNullable(batch);
            return this;
        }

        @JsonSetter(value = "card", nulls = Nulls.SKIP)
        public Builder card(Optional<CardSummary> card) {
            this.card = card;
            return this;
        }

        public Builder card(CardSummary card) {
            this.card = Optional.ofNullable(card);
            return this;
        }

        @JsonSetter(value = "authorization", nulls = Nulls.SKIP)
        public Builder authorization(Optional<AuthorizationSummary> authorization) {
            this.authorization = authorization;
            return this;
        }

        public Builder authorization(AuthorizationSummary authorization) {
            this.authorization = Optional.ofNullable(authorization);
            return this;
        }

        public Transaction build() {
            return new Transaction(
                    transactionId,
                    type,
                    date,
                    amount,
                    entryMethod,
                    createdDate,
                    lastModifiedDate,
                    status,
                    cashbackAmount,
                    interchange,
                    currency,
                    merchant,
                    settled,
                    batch,
                    card,
                    authorization,
                    additionalProperties);
        }
    }
}
